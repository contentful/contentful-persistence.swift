//
//  SynchronizationManager+SeedDB.swift
//  ContentfulPersistence
//
//  Created by JP Wright on 06.09.17.
//  Copyright Â© 2017 Contentful GmbH. All rights reserved.
//

import Foundation
import Contentful

public extension SynchronizationManager {

    /**
     This method will seed a CoreData datastore from a directory of JSON files in the specified Bundle.
     Use this method in conjunction with the ContentfulBundleSync command line interface.

     - Parameter directory: The name of the directory in your bundle which contains your Contentful JSON and media assets generated by the CLI.
     - Parameter bundle: The bundle in which your directory containing your Contentful data is located.

     - Throws: Errors if the media the files in the directory can't be deserialized.

     */
    func seedDBFromJSONFiles(in directory: String, in bundle: Bundle) throws {

        var fileIndex = 0
        let filePaths = bundle.paths(forResourcesOfType: "json", inDirectory: directory)

        let localesJSONFilePath = filePaths.filter({ URL(fileURLWithPath: $0).deletingPathExtension().lastPathComponent == "locales" }).first
        let firstFilePath = filePaths.filter({ URL(fileURLWithPath: $0).deletingPathExtension().lastPathComponent == String(fileIndex) }).first

        guard let initialSyncJSONFilePath = firstFilePath, let spaceFilePath = localesJSONFilePath else {
            throw DatabaseSeedingError.invalidFilePath
        }

        // Get the space first to give the client context.
        guard let localesData = FileManager.default.contents(atPath: spaceFilePath) else {
            let error = SDKError.invalidURL(string: spaceFilePath)
            throw error
        }

        // Extract locale information about the space and inject into the client and sync manager.
        let jsonDecoder = JSONDecoder.withoutLocalizationContext()
        let localesResponse = try jsonDecoder.decode(
            HomogeneousArrayResponse<Contentful.Locale>.self,
            from: localesData
        )
        jsonDecoder.update(with: LocalizationContext(locales: localesResponse.items)!)
        let localeCodes = localesResponse.items.map { $0.code }
        update(localeCodes: localeCodes)

        var filePath: String? = initialSyncJSONFilePath
        while let path = filePath {

            guard let data = FileManager.default.contents(atPath: path) else {
                let error = SDKError.invalidURL(string: path)
                throw error
            }
            let syncSpace = try jsonDecoder.decode(SyncSpace.self, from: data)

            self.update(with: syncSpace)

            fileIndex += 1
            filePath = filePaths.filter({ URL(fileURLWithPath: $0).deletingPathExtension().lastPathComponent == String(fileIndex)}).first
        }
    }

    /**
     Returns the local path for media assets that have been bundled in your app's bundle for the passed in `Asset` or `AssetPersistable`.
     This only works if you've used the ContentfulBundleSync command line tool.

     - Parameter media: The Asset or AssetPersistable for which on-disk data should be retreived.
     - Parameter directory: The name of the directory in your bundle which contains the media data
     - Parameter bundle: The bundle in which your directory containing your media files is located.

     - Returns: The full string path for the underlying media file associated with the passed in `Asset` or `AssetPersistabl`.
                Will return `nil` if no directory exists at your directory name, or if the `Media` does not have a valid `urlString` associated with it.
     */
    static func pathInBundle(for media: AssetProtocol, inDirectoryNamed directory: String, in bundle: Bundle) -> String? {
        let fileName = SynchronizationManager.fileName(for: media)
        return bundle.path(forResource: fileName, ofType: nil, inDirectory: directory)
    }

    /**
     Returns on-disk data that is bundled in your app's bundle for the passed in `Asset` or `AssetPersistable`.
     This only works if you've used the ContentfulBundleSync command line tool.

     - Parameter media: The Asset or AssetPersistable for which on-disk data should be retreived.
     - Parameter directory: The name of the directory in your bundle which contains the media data
     - Parameter bundle: The bundle in which your directory containing your media files is located.

     - Returns: The `Data` object for your media file. Will return `nil` if no directory exists at your directory name,
                or if the `Media` does not have a `urlString` associated with it.
     */
    static func bundledData(for media: AssetProtocol, inDirectoryNamed directory: String, in bundle: Bundle) -> Data? {
        guard let path = pathInBundle(for: media, inDirectoryNamed: directory, in: bundle) else { return nil }
        let data = FileManager.default.contents(atPath: path)
        return data
    }
    /**
     Returns a file name to be used for local storage given a passed in `Asset` or `AssetPersistable`.

     - Parameter media: The Asset or AssetPersistable for which a file name should be computed.

     - Returns: A filename for the underlying media file. Will return `nil` if the Asset or AssetPersistable
                does not have a `urlString` associated with it.
     */
    static func fileName(for media: AssetProtocol) -> String? {
        guard let urlString = media.urlString else { return nil }
        let url = URL(fileURLWithPath: urlString)
        let pathExtension = url.pathExtension.isEmpty ? "data" : url.pathExtension
        let fileName = "cache_" + media.id + "." + pathExtension
        return fileName
    }
    /**
     Errors thrown by ContentfulPersistence when trying to seed a database with bundled data.
     */
    enum DatabaseSeedingError: Swift.Error, CustomDebugStringConvertible {

        /// Thrown if there is not valid JSON stored in the directory the libarary is trying to seed
        /// a database from.
        case invalidFilePath

        public var debugDescription: String {
            switch self {
            case .invalidFilePath:
                return "No JSON file's containing Contentful Sync data were found at the specified directory path"
            }
        }

    }
}
